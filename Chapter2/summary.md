# 信息的表示和处理 #

## 信息存储 ##

1. 浮点运算由于表达的精度有限，因此是不符合结合律的运算。
2. 每个程序对象可以简单的视为一个字节块，那么程序本身就是一个字节序列。
3. 一个字节的值域：二进制（$00000000$～$11111111$）、十进制（$0$～$255$）、十六进制（$0$～$FF$）。
4. 将 $2^n$ 转为十六进制：将 $n$ 转换为 $i+4j$，通过将 $i$ 映射成十六进制最高位数字，再添加 $j$ 个尾部 $0$。
5. 保证程序的可移植性即确保程序对不同数据类型的确切大小不敏感。
6. 在大部分机器上，多字节对象都被存储为连续的字节序列，对象的地址为所使用字节中的最小地址。
7. 小端：低地址存储低有效字节（例如手写数字的右端）；大端：低地址存储高有效字节（例如手写数字的左端）。
8. 字符串的字节顺序不受字大小或大小端的影响，因此文本数据比二进制数据具有更强的平台独立性。
9. 二进制代码很少能在不同机器和操作系统的组合间移植，因此二进制代码是不兼容的。
10. 布尔运算：满足 & 对 | 的分配律、| 对 & 的分配律，由运算 ^、&、~ 构成布尔环，其中加法运算 ^ 的加法逆元是它自己本身（即a^a=0）。
11. 使用位向量来表示有限集合：向量$a=[01101001]$，表示集合$A=\{0,3,5,6\}$，向量$b=[01010101]$，表示集合$B=\{0,2,4,6\}$，此时 | 对应集合的并（$\cup$），& 对应集合的交（$\cap$），~ 对应集合的补集（$A-B$）。
12. C语言的逻辑运算符具有短路性质。
13. 移位运算符：左移、右移（算数右移补齐最高有效位的值、逻辑右移补零），几乎所有编译器/机器组合对有符号数据使用算数右移。
14. 移位操作的数量应该保持小于字长。

## 整数表示 ##

1. 二进制数映射到无符号数（双射）：

$$
B2U_w(\overrightarrow{x})\xlongequal{def}\sum_{i=0}^{w-1}x_i\cdotp2^i
$$
2. 补码，将字的最高有效位解释为负权（符号位），二进制数映射到有符号补码数（双射）：

$$
B2T_w(\overrightarrow{x})\xlongequal{def}-x_{w-1}2^{w-1}+\sum_{i=0}^{w-2}x_i\cdotp2^i
$$
3. 无符号数最大值$UMax$，有符号数的最小值$TMin$，有符号数的最大值$TMax$，并有：

$$
UMax=2TMax+1
$$
$$
|TMin|=|TMax|+1
$$
4. 一个负数的二进制补码与它的相反数的二进制的反码$+1$的二进制表示一样。
5. C语言的强制类型转换保持二进制位值不变，只是改变了解释这些位的方式。
6. 有符号数转换成无符号数：

$$
T2U_w(x)=x_{w-1}2^w+x
$$
7. 进一步推得：

$$
T2U_w(x)=\begin{cases}
   x+2^w &x<0  \\
   x &x\geq0
\end{cases}
$$
8. 同理无符号数转换成有符号数：

$$
U2T_w(u)=\begin{cases}
    u &u<2^{w-1} \\
    u-2^w &u\geq2^{w-1}
\end{cases}
$$
9. C语言在处理一个运算数是有符号的而另一个是无符号的时，会将有符号数强制类型转换为无符号数，并且假设这两个数都是非负的来执行运算（即纯粹的位运算）。
10. 无符号数采用零扩展来扩展数字的位表示，而有符号数则采用符号扩展。
11. 当类型转换和扩展同时发生时，先进行扩展再进行类型转换。（例如short变为unsigned，先将$16$位进行符号扩展到$32$位再将其解释为unsigned）
12. 将一个$w$位的数截断为一个$k$位的数字时，我们会丢弃高$w-k$位，截断一个数字可能会改变它的值。补码数字的截断结果为：将截断后的$k$位无符号数转换为$k$位有符号数。

## 整数运算 ##

1. 执行两个无符号数值加法时：

$$
x+_w^u{y}=\begin{cases}
    x+y &x+y<2^w \\
    x+y-2^w &2^w\leq{x}+y<2^{w+1}
\end{cases}
$$
2. 判断无符号数是否溢出：令$s=x+y$，当且仅当$s<x$（或者等价地$s<y$）
3. 模数加法形成的阿贝尔群，其中每个元素都有一个加法逆元：

$$
-_w^u{x}=\begin{cases}
    x &x=0 \\
    2^w-x &x>0
\end{cases}
$$
4. 补码加法分为三种情况：

$$
x+_w^t{y}=\begin{cases}
    x+y-2^w &2^{w-1}\leq{x}+y \\
    x+y &-2^{w-1}\leq{x}+y<2^{w-1} \\
    x+y+2^w &x+y<-2^{w-1}
\end{cases}
$$
5. 正溢出和负溢出的判断，当$x,y$都是负数且$x+_w^t{y}\geq0$时发生了负溢出，当$x,y$都是正数且$x+_w^t{y}\leq0$时发生了正溢出。
6. 补码的非运算对于范围$-2^{w-1}\leq{x}<2^{w-1}$：

$$
-_w^t{x}=\begin{cases}
    -2^{w-1} &x=-2^{w-1} \\
    -x &x>-2^{w-1}
\end{cases}
$$
7. 快速求一个补码的非，方法1可以将该补码的位级表示取反再$+1$，方法2可以对其位级表示的最右边一个$1$不变（只要不是全为$0$），其他位求反。
8. 有符号和无符号加法、减法和乘法运算的位级表示的结果是相同的。
9. 使用加减和移位运算的组合来替代常数因子的乘法：考虑常数$K$的二进制表示$[(0\cdots0)(1\cdots1)(0\cdots0)\cdots(1\cdots1)]$，考虑一组从位位置$n$到位位置$m$的连续的$1$（设$n>m$），可以用以下两种形式来计算这些位对乘积的影响：$(x\ll{n})+(x\ll{n}-1)+\cdots+(x\ll{m})$或者$(x\ll{n+1})-(x\ll{m})$。
10. 一个数除以$2$的幂，非负数使用逻辑右移实现；而负数的算术右移则会导致结果向下舍入，因此在有舍入发生时，将一个负数右移$k$位不等于整除$2^k$的结果：表达式$(x<0?(x+(1\ll{k})-1):x)\gg{k})$等价于算术右移的整除结果。

## 浮点数 ##

1. 二进制小数的表示形式：

$$
b=\sum_{i=-n}^{m}2^i\cdotp{b_i}
$$
2. IEEE浮点标准用$V=(-1)^s\cdotp{M}\cdotp{2^E}$的形式来表示一个数：符号$s$决定这个数是负数还是正数，而对于数值$0$的符号位解释作为特殊情况处理。尾数$M$是一个二进制小数，它的范围是$1\sim2-\varepsilon$，或者是$0\sim1-\varepsilon$。阶码$E$的作用是对浮点数加权，这个权重是$2^E$（可能是负数）。具体的位构成如下：

    - 单独的符号位$s$直接编码符号$s$
    - $k$位的阶码字段$\text{exp}=e_{k-1}\cdots{e_1}e_0$编码阶码$E$
    - $n$位的小数字段$\text{frac}=f_{n-1}\cdots{f_1}f_0$编码尾数$M$
3. 单精度下$k=8,n=23$，双精度下$k=11,n=52$。
4. 阶码$E$的三种情况：

    - **规格化的值**，当位模式不全为0或1时，阶码的值是$E=e-Bias$，其中$e$是阶码二进制表示的无符号数，偏置值$Bias=2^{k-1}-1$。此时，尾数$M$定义为$M=1+f$，其中$f$的二进制表示为$0.f_{n-1}\cdots{f_1}f_0$。
    - **非规格化的值**，当阶码全为$0$时，$E=1-Bias$。此时尾数$M=f$。非规格化的值作用：一是提供了一种表示数值0的方法，二是表示那些非常接近于$0.0$的数。
    - **特殊值**，当阶码全为$1$，小数全为$0$时，若符号位为$0$表示数$+	\infty$，若符号位为$1$表示数$-\infty$。当阶码全为$1$且小数为非$0$时，结果值被称为$\text{NaN}$表示不是一个数。

5. 最大的非规格化数与最小的规格化数之间的平滑转变，归功于对非规格化数的$E$的定义。通过将$E$定义为$1-Bias$，而不是$-Bias$，我们可以补偿非规格化数的尾数没有隐含的开头的$1$。
6. IEEE浮点格式定义了四种不同的**舍入方式**：向偶数舍入、向零舍入、向下舍入、向上舍入。其中向偶数舍入（向最接近的值舍入）是默认的舍入方式，它在大多数现实情况中避免了向下或向上舍入带来的平均值统计偏差。我们将最低有效位的值$0$认为是偶数，值$1$认为是奇数。一般来说，只有对形如$XX\cdots{X}.YY\cdots{Y}100\cdots$的二进制位模式的数，这种舍入方式才有效，其中$X$和$Y$表示任意位值，最右边的$Y$是要被舍入的位置。
7. 浮点运算是可交换，不可结合的。大多数值在浮点加法下都有逆元（除了无穷和$NaN$）。浮点加法满足单调性，即如果$a\geq{b}$，那么对于任何$a b$以及$x$的值，除了$NaN$，都有$x+a\geq{x}+b$。浮点乘法在加法上不具备分配性。
8. 当在int、float和double格式之间进行强制类型转换时：

    - int -> float 数字不溢出，但可能被舍入。
    - int or float -> double 精确。
    - double -> float 可能溢出成$+\infty$或$-\infty$，由于精度较小，还可能被舍入。
    - float or double -> int 值会向零舍入。值可能会溢出，（Intel兼容的微处理器）一个浮点数到整数的转换，如果不能为该浮点数找到一个合理的整数近似值，就会产生一个整数不确定值（位模式$[10\cdots00]$，字长为$w$时的$TMin_w$），因此会从一个正值变成一个负值。

## 家庭作业未完成 ##

- 65、66、75、96、97