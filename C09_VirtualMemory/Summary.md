# 虚拟内存 #

1. 虚拟内存（VM），是硬件异常、硬件地址翻译、主存、磁盘文件和内核软件的完美交互，它为每个进程提供了一个大的、一致的和私有的地址空间。

## 物理和虚拟寻址 ##

1. 计算机系统的主存被组织成一个由M个连续的字节大小的单元组成的数组，每字节都有一个唯一的物理地址。物理寻址就是指使用物理地址在内存中读取数据。

2. 虚拟寻址，CPU通过生成一个虚拟地址来访问主存，虚拟地址在被送到内存之前先转换成适当的物理地址。将一个虚拟地址转换为物理地址的任务叫做地址翻译。CPU专用硬件**内存管理单元（MMU）**，利用存放在主存中的查询表来动态翻译虚拟地址，该表的内容由操作系统管理。

## 地址空间 ##

1. 连续的地址空间称为线性地址空间。一个地址空间的大小是由标示最大地址所需要的位数来描述的，一个包含$N=2^n$个地址的虚拟地址空间就叫做一个n位地址空间。

## 虚拟内存做为缓存的工具 ##

1. VM系统通过将虚拟内存分割为称为**虚拟页**的大小固定的块来处理这个问题。每个虚拟页的大小为$P=2^p$字节。物理内存被分割为**物理页**，大小也为P字节（被称为页帧）。在任意时刻，虚拟页面的集合都分为三个不相交的子集：
    - 未分配的，VM系统还未分配（或者创建）的页。
    - 缓存的，当前已缓存在物理内存中的已分配页。
    - 未缓存的，未缓存在物理内存中的已分配页。

2. 由于大的不命中处罚和访问第一个字节的开销，虚拟页往往很大（4KB～2MB）。DRAM缓存是全相联的，即任何虚拟页都可以放置在任何的物理页中。DRAM缓存总是使用写回，而不是直写。

3. 存放在物理内存中叫做**页表**的数据结构，将虚拟页映射到物理页。页表就是一个页表条目（PTE）的数组。虚拟地址空间中的每个页在页表中一个固定偏移量处都有一个PTE。

4. 局部性原则抱枕改了在任意时刻，程序将趋向于在一个较小的活动页面集合上工作，这个集合叫做工作集或者常驻集合。没有展现良好的时间局部性的程序，如果工作集的大小超出了物理内存的大小，那么程序将发生抖动，这时页面将不断地换进换出。

## 虚拟内存作为内存管理工具 ##

1. 操作系统为每个进程提供了一个独立的页表，因而页就是一个独立的虚拟地址空间。多个虚拟页面可以映射到同一个共享物理页面上。

2. 按需页面调度和独立的虚拟地址空间的结合，使VM简化了链接和加载、代码和数据共享，以及应用程序的内存分配：
    - 简化链接，独立的地址空间允许每个进程的内存映像使用相同的基本格式，而不管代码和数据实际存放在物理内存的何处。例如对于64位地址空间，代码段总是从虚拟地址0x400000开始。
    - 简化加载，虚拟内存为代码和数据段分配虚拟页，把它们标记为无效的（即未被缓存的），将页表条目指向目标文件中适当的位置。加载器从不从磁盘到内存实际复制任何数据。将一组连续的虚拟页映射到任意一个文件中的任意位置的表示法称作**内存映射**。
    - 简化共享，独立地址空间为操作系统提供了一个管理用户进程和操作系统自身之间共享的一致机制。操作系统通过将不同进程中适当的虚拟页面映射到相同的物理页面，从而安排多个进程共享这部分代码的一个副本。
    - 简化内存分配，虚拟内存为向用户进程提供一个简单的分配额外内存的机制，操作系统分配一个适当数字（k）个连续的虚拟内存页面，并且将它们映射到物理内存中任意位置的k个任意的物理页面。

## 虚拟内存做为内存保护工具 ##

1. 用额外的许可位来控制对一个虚拟页面内容的访问，如果一条指令违反了这些许可条件，那么CPU就触发一个一般保护故障，将控制传递给一个内核中的异常处理程序。（段错误segmentation fault）

## 地址翻译 ##

1. 描述使用的符号表：

|符号|描述|
|--|--|
|N=$2^n$|虚拟地址空间中的地址数量|
|M=$2^m$|物理地址空间中的地址数量|
|P=$2^p$|页的大小（字节）|
|VPO|虚拟页面偏移量（字节）（由虚拟页大小决定）|
|VPN|虚拟页号（除去VPO的剩余位）|
|TLBI|TLB组索引（由组数量决定）|
|TLBT|TLB标记（VPN除去TLBI的剩余位）|
|PPO|物理页面偏移量（字节）|
|PPN|物理页号|
|CO|缓冲块内的字节偏移量|
|CI|高速缓存索引|
|CT|高速缓存标记|

2. CPU中的一个控制寄存器，页表基址寄存器（PTBR）指向当前页表。n位的虚拟地址包含两个部分：一个p位的虚拟页面偏移（VPO）和一个（n-p）位的虚拟页号（VPN）。使用VPN选择对应的PTE。将页表条目中的物理页号和虚拟地址中的VPO串联起来，就得到相应的物理地址。

3. 在任何既使用虚拟内存又使用SRAM高速缓存的系统中，都使用物理寻址的方式在高速缓存中查找数据或PTE。主要的思路是地址翻译发生在高速缓存查找之前。

4. 翻译后备缓冲器（TLB）用来缓存PTE，其中每一行都保存着一个由单个PTE组成的块。如果TLB有T=$2^t$个族，那么TLB索引（TLBI）是由VPN的t个最低位组成的，而TLB标记（TLBT）是由VPN中剩余的位组成的。

5. 多级页表，在一级页表中的每个PTE负责映射虚拟地址空间中一个固定大小（4MB）的片，每一个片都是由许多个连续的页面组成的。如果片i中的每个页面都未被分配，那么一级PTE的i就为空。如果在片i中至少有一个页是分配了的，那么一级PTE的i就指向一个二级页表的基址。由于TLB的作用，带多级页表的地址翻译（访问k个PTE）并不比单级页表慢很多。

## 案例研究：Intel Core i7/Linux内存系统 ##

1. 第一、二和三级页表中条目的格式：

|字段|描述|起始结束位|
|---|---|---|
|P|子页表在物理内存中（1），不在（0）|0|
|R/W|对于所有可访问页，只读或者读写访问权限|1|
|U/S|对于所有可访问页，用户或超级用户（内核）模式访问权限|2|
|WT|子也表的直写或写回缓存策略|3|
|CD|能/不能缓存子也表|4|
|A|引用位（由MMU在读和写时设置，由软件清除）|5|
|PS|页大小为4KB或4MB（只对第一层PTE定义|7|
|Base addr|子也表的物理基地址的最高40位|12～51|
|XD|能/不能从这个PTE可访问的所有页中取指令|63|
|D|修改位（由MMU在读和写时设置，由软件清除），又称为修改位或脏位。告诉内核在复制替换页之前是否必须写回牺牲页|6|
|G|全局页（在任务切换时，不从TLB中驱逐出去）|8|

2. Linux将虚拟内存组织成一些区域（段）的集合。一个区域就是已经存在着的（已分配的）虚拟内存的连续片，这些页是以某种方式相关联的。每个存在的虚拟页面都保存在某个区域中，而不属于某个区域的虚拟页是不存在的，并且不能被进程引用。内核不用记录那些不存在的虚拟页。

3. mm_struct描述了虚拟内存的当前状态，其中pgd字段指向第一级页表（页全局目录）的基址，而mmap指向一个vm_area_structs（区域结构）的链表，其中每个vm_area_structs都描述了当前虚拟地址空间的一个区域。

## 内存映射 ##

1. Linux通过将一个虚拟内存区域与一个磁盘上的对象关联起来，以初始化这个虚拟内存区域的内容，这个过程称为**内存映射**：
    - Linux文件系统中的普通文件，一个区域可以映射到一个普通磁盘文件的连续部分。
    - 匿名文件，一个区域页可以映射到一个匿名文件，匿名文件是由内核创建的，包含的全是二进制零。映射到匿名文件的区域中的页面有时也叫做请求二进制零的页。

2. 一个进程将一个共享对象映射到它的虚拟地址空间的一个区域内，那么这个进程对这个区域的任何写操作，对于那些也把这个共享对象映射到它们虚拟内存的其他进程而言，也是可见的。变化也会反映在磁盘上的原始对象中。对于一个映射到私有对象的区域做的改变，对于其他进程来说是不可见的，并且进程对这个区域所做的任何写操作都不会反映在磁盘上的对象中。

3. 私有对象使用一种叫做写时复制的巧妙技术被映射到虚拟内存中。一个私有对象开始生命周期的方式基本上与共享对象的一样，在物理内存中只保存有私有对象的一份副本。对于每个映射私有对象的进程，相应私有区域的页表条目都被标记为只读，并且区域结构被标记为私有的写时复制。只要有一个进程试图写私有区域内的某个页面，那么这个写操作就会触发一个保护故障，它会在物理内存中创建这个页面的一个新副本，更新页表条目指向这个新的副本，然后恢复这个页面的可写权限。

4. execve函数加载并运行程序需要以下几个步骤：
    - 删除已存在的用户区域，删除当前进程虚拟地址的用户部分中的已存在的区域结构。
    - 映射私有区域，为新程序的代码、数据、bss和栈区域创建新的区域结构（私有、写时复制）。
    - 映射共享区域。
    - 设置程序计数器。

5. Linux进程可以使用mmap函数来创建新的虚拟内存区域，并将对象映射到这些区域中：
    - PROT_EXEC，这个区域内的页面由可以被CPU执行的指令组成。
    - PROT_READ，这个区域内的页面可读。
    - PROT_WRITE，这个区域内的页面可写。
    - PROT_NONE，这个区域内的页面不能被访问。
    - MAP_ANON，被映射的对象是一个匿名对象。
    - MAP_PRIVATE，被映射的对象是一个私有的、写时复制的对象。
    - MAP_SHARED，共享对象。
    munmap函数删除从虚拟地址start开始的，由接下来length字节组成的区域。

## 动态内存分配 ##

1. 动态内存分配器维护着一个进程的虚拟内存区域，称为堆。对于每个进程，内核维护着一个变量brk，它指向堆的顶部。分配器将堆视为一组不同大小的块的集合来维护。每个块就是一个连续的虚拟内存片，要么是已分配的，要么是空闲的。分配器有两种基本风格，都要求应用显式地分配块。不同之处在于由哪个实体来负责释放已分配的块：
    - 显式分配器，要求应用显式地释放任何已分配的块。
    - 隐式分配器，也叫做垃圾收集器。自动释放未使用的已分配的块的过程叫做垃圾收集。

2. 有关函数：
    - malloc，返回一个指针，指向大小为至少size字节的内存块，如果遇到问题则返回NULL，并设置errno。
    - calloc，基于malloc的瘦包装函数，将分配的内存初始化为零。
    - realloc，改变一个以前已分配块的大小。
    - sbrk，通过将内和的brk指针增加incr来扩展和收缩堆。incr为零，sbrk就返回brk的当前值。incr为负，返回值指向距新堆顶向上abs（incr）字节处。

3. 显式分配器工作的约束条件：
    - 处理任意请求序列，分配器不能假设所有的分配请求都有相匹配的释放请求。
    - 立即响应请求，不允许分配器为了提高性能重新排列或者缓冲请求。
    - 只使用堆，分配器使用的任何非标量数据结构都必须保存在堆里。
    - 对齐块，分配器必须对齐块，使得它们可以保存任何类型的数据对象。
    - 不修改已分配的块，分配器只能操作或者改变空闲块。诸如压缩已分配块这样的技术是不允许使用的。

4. 造成堆利用率很低的主要原因是一种称为**碎片**的现象，当虽然有未使用的内存但不能用来满足分配请求时，就发生这种现象：
    - 内部碎片，是在一个已分配块比有效载荷大时发生的。分配器的实现可能堆已分配块强加一个最小的大小值，而这个大小要比某个请求的有效载荷大。
    - 外部碎片，是当空闲内存合计起来足够满足一个分配请求，但是没有一个单独的空闲块足够大可以来处理这个请求时发生的。

5. **隐式空闲列表**中，一个块是由一个字的头部、有效载荷，以及可能的一些额外的填充组成的。系统对齐要求和分配器对块格式的选择会对分配器上的最小块大小有强制的要求。没有已分配块或者空闲块可以比这个最小值还小。

6. **显式空闲列表**，将空闲块组织为某种形式的显式数据结构。实现这个数据结构的指针可以存放在这些空闲块的主体里面。这样使得首次适配的分配时间从块总数的线性时间减少到了空闲块数量的线性时间。释放一个块的时间可以是线性的，也可能是个常数。

7. 放置匹配块的三种方式：
    - 首次适配
    - 下一次适配
    - 最佳适配

8. 如果分配器不能为请求块找到合适的空间块，将有可能合并（那些在内存中物理上——虚拟内存堆）相邻的空闲块来创建一些更大的空闲块。或者通过调用sbrk函数，向内核请求额外的堆内存，转化成一个大的空闲块。

9. **分离存储**，维护多个空闲链表，其中每个链表中的块有大致相等的大小。一般的思路是将所有可能的块大小分成一些等价类，也叫做大小类。分配器维护着一个空闲链表数组，每个大小类一个空闲链表，按照大小的升序排列。当分配器需要一个大小为n的块时，它就搜索相应的空闲链表。如果不能找到合适的块与之匹配，继续搜索下一个链表。

10. **伙伴系统**，是分离适配的一个特例，其中每个大小类都是2的幂。为每个块大小$2^k$维护一个分离空闲链表，请求块大小向上舍入到最接近的2的幂。为了分配一个大小为$2^k$的块，我们找到第一个可用的、大小为$2^j$的块，如果j=k那么就完成了。否则递归地二分割这个块，直到j=k。每个剩下的半块（伙伴）被放置在相应的空闲链表中。一个块的地址和它的伙伴的地址只有一位不相同。

## 垃圾收集 ##

1. 垃圾收集器将内存视为一张有向可达图，该图的节点被分成一组根节点和一组堆节点。每个堆节点对应于堆中一个已分配块。有向边p->q意味着块p中的某个位置指向块q中的某个位置。根节点对应于这样一种不在堆中的位置，它们中包含指向堆中的指针。节点p可达，意味着存在一条从任意根节点出发并到达p的有向路径。不可达节点对应于垃圾。垃圾收集器的角色是维护可达图的某种表示，并通过释放不可达节点并将它们返回给空闲链表。

2. Mark & Sweep收集器必须是保守的，其根本原因是C语言不会用类型信息来标记内存位置。因此，像int或者float这样的标量可以伪装成指针。

## C程序中常见的与内存有关的错误 ##

1. 常见的与内存有关的错误：
    - 间接引用坏指针
    - 读未初始化的内存
    - 允许栈缓冲区溢出
    - 假设指针和它们只想的对象是相同大小的
    - 造成错位错误
    - 引用指针，而不是它所指向的对象
    - 误解指针运算
    - 引用不存在的变量
    - 引用空闲堆块中的数据
    - 引起内存泄漏

## 家庭作业未完成 ##

- 17、18、20
