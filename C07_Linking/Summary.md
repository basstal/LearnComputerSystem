# 链接 #

1. 链接器使得软件开发中**分离编译**成为可能，可以将大型的应用程序组织成更小、更好管理的模块，独立地修改和编译这些模块。

## 编译器驱动程序 ##

## 静态链接 ##

1. **静态链接器**以一组可重定位目标文件和命令行参数作为输入，生成一个完全链接的、可以加载和运行的可执行目标文件作为输出。

2. 链接器必须完成两个主要任务：
    - 符号解析，将每个符号引用（对应一个函数、一个全局变量或一个静态变量）关联到一个符号定义。
    - 重定位，链接器通过把每个符号定义与一个内存位置关联起来，从而重定位这些节，然后修改所有对这些符号的引用，使得它们指向这个内存位置。

## 目标文件 ##

1. 目标文件有三种形式：
    - 可重定位目标文件。可与其他可重定位目标文件合并起来，创建可执行目标文件。
    - 可执行目标文件。可以被直接复制到内存并执行。
    - 共享目标文件。特殊类型的可重定位目标文件，可以在加载或运行时被动态地加载进内存并链接。

## 可重定位目标文件 ##

1. 一个典型的ELF可重定位目标文件包含下面几个节：
    - .text     已编译程序的机器代码。
    - .rodata   只读数据（例如switch跳转表和printf中格式化字符串）。
    - .data     已初始化的全局和静态C变量。
    - .bss      未初始化的静态C变量，以及所有被初始化为0的全局或静态变量。
    - .symtab   符号表，存放在程序中定义和引用的函数和全局变量的信息。
    - .rel.text 一个.text节中位置的列表，当链接器把这个目标文件和其他文件组合时，需要修改这些位置。
    - .rel.data 被模块引用或定义的所有全局变量的重定位信息。
    - .debug    调试符号表，其条目是程序中定义的局部变量和类型定义，只有-g才会得到这张表。
    - .line     原始C源程序中的行号和.text节中机器指令之间的映射，只有-g才会得到这张表。
    - .strtab   字符串表，其内容包括.symtab和.debug节中的符号表，以及节头部中的节名字。

## 符号和符号表 ##

1. 每个可重定位目标模块都有一个符号表，在链接器的上下文中，有三种不同的符号：
    - 由自己定义并能被其他模块引用的全局符号。对应于非静态的C函数和全局变量。
    - 由其他模块定义并被自己引用的全局符号。称为外部符号，对应其他模块中定义的非静态C函数和全局变量。
    - 只被自己定义和引用的局部符号。对应带static属性的C函数和全局变量。在自己模块中任何位置都可见，但是不能被其他模块引用。

2. .symtab中的符号表不包含对应于本地非静态程序变量的任何符号。这些符号在运行时在栈中被管理。

3. ELF符号表条目：
    - int name          字符串表中的字节偏移，指向符号的以null结尾的字符串名字。
    - char type：4      通常要么是数据，要么是函数。
    - char binding：4   表示符号是本地的还是全局的。
    - char reserved     未使用。
    - short section     每个符号都被分配到目标文件的某个节，section字段是一个到节头部表的索引，有三个特殊的伪节，ABS代表不该被重定位的符号；UNDEF代表未定义的符号（在本目标模块中引用但是在其他地方定义的符号）；COMMON表示还未被分配位置的未初始化的数据目标（对于COMMON，value给出对齐要求，size给出最小大小），这些伪节只在可重定位目标文件中才有。
    - long value        是距定义目标的节的起始位置的偏移。对于可执行目标文件，是一个绝对运行时地址。
    - long size         目标的大小（以字节为单位）。

## 符号解析 ##

1. 链接器解析符号引用的方法是将每个引用与它输入的可重定位目标文件的符号表中的一个确定的符号定义关联起来。对那些和引用定义在相同模块中的局部符号的引用，编译器只允许每个模块中每个局部符号有一个定义。

2. 当编译器遇到一个不是在当前模块中定义的符号时，会假设该符号是在其他某个模块中定义的，生成一个链接器符号表条目，并把它交给链接器处理。

3. Linux采用强（函数和已初始化的全局变量）或者弱（未初始化的全局变量）规则：
    - 不允许有多个同名的强符号。
    - 如果有一个强符号和多个弱符号同名，那么选择强符号。
    - 如果有多个弱符号同名，任意选择一个。

4. 编译系统提供一种机制，将所有相关的目标模块打包成为一个单独的文件，称为**静态库**，它可以用作链接器的输入，只复制静态库里被应用程序引用的目标模块到可执行文件中。

## 重定位 ##

1. 重定位将合并输入模块，并为每个符号分配运行时地址：
    - 重定位节和符号定义。将相同类型的节合并为同一类型的新的聚合节，当这一步完成时，程序中的每条指令和全局变量都有唯一的运行时地址。
    - 重定位节中的符号引用。修改代码节和数据节中对每个符号的引用，使得它们指向正确的运行时地址。

2. 当汇编器遇到对最终位置未知的目标引用，它会生成一个重定位条目，告诉链接器在将目标文件合并成可执行文件时如何修改这个引用。代码的重定位条目放在.rel.text中，已初始化数据的重定位条目放在.rel.data中。

3. ELF重定位条目：
    - long offset，需要被修改的引用的节偏移。
    - long type：32，告知链接器如何修改新的引用。
            symbol：32，标识被修改引用应该指向的符号。
    - long addend，有符号常数，一些类型的重定位要使用它对被修改引用的值做偏移调整。

4. gcc默认使用**小型代码模型**，该模型假设可执行目标文件中的代码和数据的总体大小小于2GB。

5. 重定位PC相对引用地址计算方式：
    - refaddr = ADDR(s) + r.offset
    - *refptr = (unsigned) (ADDR(r.symbol) + r.addend - refaddr)

6. 重定位绝对引用地址计算方式：
    - *refptr = (unsigned) (ADDR(r.symbol) + r.addend)

## 可执行目标文件 ##

1. 典型ELF可执行目标文件：
    - EFL头。
    - 段头部表，将连续的文件节映射到运行时内存段。
    - .init，程序的初始化代码会调用它。
    - .text。
    - .rodata。
    - .data。
    - .bss。
    - .symtab。
    - .debug。
    - .line。
    - .strtab。
    - 节头部表，描述目标文件的节。

2. ELF可执行文件的连续的片被映射到连续的内存段。程序头部表描述了这种映射关系。

## 加载可执行目标文件 ##

1. 每个Linux程序都有一个运行时内存映像，代码段从地址0x400000处开始，后面是数据段。运行时堆在数据段之后，通过调用malloc库往上增长。堆后面的区域是为共享模块保留的。用户栈总是从最大的合法用户地址开始，向较小内存地址增长。栈上的区域（$2^{48}$）是为内核中的代码和数据保留的。

## 动态链接共享库 ##

1. 共享库是为解决静态链接拷贝函数的问题和更新的问题而出现的，共享库是一个目标模块，在运行或加载时可以动态的加载到任意的内存地址，并和一个在内存中的程序链接起来。

## 从应用程序中加载和链接共享库 ##

1. Linux中加载和链接共享库：
    - dlopen，加载和链接共享库。
    - dlsym，输入一个前面已经打开了的共享库的句柄和symbol名字。
    - dlclose，如果没有其他共享库还在使用这个共享库，就卸载这个共享库。
    - dlerror，最近发生的错误。

## 位置无关代码 ##

1. 可以加载而无需重定位的代码成为**位置无关代码**。

2. PIC数据引用（无论我们在内存中何处加载一个目标模块，代码段与数据段的距离保持不变，因此代码段中任何指令和数据段中任何变量之间的距离都是一个运行时常量），通过使用**全局偏移量表（GOT）**，每个被这个目标模块引用的全局数据目标都有一个8字节条目。编译器还为GOT中每个条目生成一个重定位记录。在加载时，动态链接器会重定位GOT中每个条目，使得它包含目标的正确的绝对地址，每个引用全局目标的目标模块都有自己的GOT。

3. PIC函数调用，**延迟绑定**将过程地址的绑定推迟到第一次调用该过程时。使用GOT和PLT（过程链接表）来实现延迟绑定。GOT是数据段的一部分而PLT是代码段的一部分。PLT是一个每个条目16字节的数组，每个被可执行程序调用的库函数都有它自己的PLT条目，每个条目都负责调用一个具体的函数。每个GOT条目都有一个相匹配的PLT条目。

## 库打桩机制 ##

1. 三种方式：编译时打桩，链接时打桩，运行时打桩。

## 处理目标文件的工具 ##

## 家庭作业未完成 ##

- 13
