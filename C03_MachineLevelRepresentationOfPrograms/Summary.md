# 程序的机器级表示 #

## 历史观点 ##

## 程序编码 ##

1. C预处理器处理include和define等宏命令；编译器产生源文件的汇编代码（*.s）；汇编器将汇编代码转为二进制目标代码文件（*.o），目标代码包含所有指令的二进制表示，但没有填入全局值的地址；最后，链接器将目标代码与实现库（例如printf）的代码合并，产生可执行文件。
2. 对于机器级编程重要的两种抽象：

    - ISA，指令集体系结构或指令集架构，它定义了处理器状态、指令的格式，以及每条指令对状态的影响。
    - 虚拟地址，内存模型看上去是一个非常大的字节数组。
3. 机器代码可见的处理器状态信息：

    - PC，程序计数器（%rip），给出将要执行的下一条指令在内存中的地址。
    - 整数寄存器，包含16个命名的位置，分别存储64位的值。用来记录程序状态或保存临时数据。
    - 条件码寄存器，保存着最近执行的算术或逻辑指令的状态信息。用来实现控制或数据流中的条件变化。
    - 一组向量寄存器，存放一个或多个整数或浮点数值。

## 数据格式 ##

## 访问信息 ##

1. 整数寄存器。所有16个寄存器的低位部分都可以作为字节、字（16位）、双字（32位）和四字（64位）数字来访问：

| 64 | 32  | 16  | 8    |   描述    |
|----|-----|-----|------|-----------|
|rax |eax  |ax   | al   |返回值      |
|rbx |ebx  |bx   | bl   |被调用者保存 |
|rcx |ecx  |cx   | cl   |第4个参数   |
|rdx |edx  |dx   | dl   |第3个参数   |
|rsi |esi  |si   | sil  |第2个参数   |
|rdi |edi  |di   | dil  |第1个参数   |
|rbp |ebp  |bp   | bpl  |被调用者保存 |
|rsp |esp  |sp   | spl  |栈指针      |
|r8  |r8d  |r8w  | r8b  |第5个参数   |
|r9  |r9d  |r9w  | r9b  |第6个参数   |
|r10 |r10d |r10w | r10b |调用者保存  |
|r11 |r11d |r11w | r11b |调用者保存  |
|r12 |r12d |r12w | r12b |被调用者保存 |
|r13 |r13d |r13w | r13b |被调用者保存 |
|r14 |r14d |r14w | r14b |被调用者保存 |
|r15 |r15d |r15w | r15b |被调用者保存 |

2. 生成1字节和2字节数字的指令会保持剩下的字节不变；生成4字节数字的指令会把高位4字节置为0。
3. 大多数指令有一个或多个操作数，指示出执行一个操作中要使用的源数据值，以及放置结果的目的位置：

    - 立即数，用来表示常数值。书写方式是'$'后面跟一个标准C整数。
    - 寄存器，表示某个寄存器的内容。
    - 内存引用，根据计算出来的地址（有效地址）访问某个内存位置。

4. 寻址模式，四个组成部分（立即数偏移Imm，基址寄存器$\text{r}_b$必须64位，变址寄存器$\text{r}_i$必须64位，比例因子s必须是1、2、4或者8）：

|   类型    |   格式                            |   操作数值                                      |   名称              |
|----------|-----------------------------------|-----------------------------------------------|--------------------|
|   立即数  |   $Imm                            |   Imm                                         |   立即数寻址         |
|   寄存器  |$\text{r}_a$                       |R[$\text{r}_a$]                                |   寄存器寻址         |
|   存储器  |   Imm                             |M[Imm]                                         |   绝对寻址           |
|   存储器  |($\text{r}_a$)                     |M[R[$\text{r}_a$]]                             |   间接寻址           |
|   存储器  |Imm($\text{r}_b$)                  |M[Imm+R[$\text{r}_b$]]                         |   (基址+偏移量)寻址   |
|   存储器  |($\text{r}_b$,$\text{r}_i$)        |M[R[$\text{r}_b$]+R[$\text{r}_i$]]             |   变址寻址           |
|   存储器  |Imm($\text{r}_b$,$\text{r}_i$)     |M[Imm+R[$\text{r}_b$]+R[$\text{r}_i$]]         |   变址寻址           |
|   存储器  |(,$\text{r}_i$,s)                  |M[R[$\text{r}_i$]$\cdot$s]                     |   比例变址寻址        |
|   存储器  |Imm(,$\text{r}_i$,s)               |M[Imm+R[$\text{r}_i$]$\cdot$s]                 |   比例变址寻址        |
|   存储器  |($\text{r}_b$,$\text{r}_i$,s)      |M[R[$\text{r}_b$]+R[$\text{r}_i$]$\cdot$s]     |   比例变址寻址        |
|   存储器  |Imm($\text{r}_b$,$\text{r}_i$,s)   |M[Imm+R[$\text{r}_b$]+R[$\text{r}_i$]$\cdot$s] |   比例变址寻址        |

5. 数据传送指令：

    - （MOV S,D）（'b'\'w'\'l'\'q'），第一个是源操作数，第二个是目的操作数。寄存器部分的大小必须与指令最后一个字符指定的大小匹配。特殊的用movabsq指令以任意64位立即数值作为源操作数，并且只能以寄存器作为目的。
    - （MOVZ S,R）（'bw'\'bl'\'bq'\'wl'\'wq'），以零扩展进行传送。将较小的源值复制到较大的目的时使用，以寄存器或内存地址作为源，以寄存器作为目的。特殊的没有movzlq，可以用movl指令来实现。利用的属性是，生成4字节值并以寄存器作为目的的指令会把高4字节置为0。
    - （MOVS S,R）（'bw'\'bl'\'bq'\'wl'\'wq'\'lq'），以符号扩展进行传送。将较小的源值复制到较大的目的时使用，以寄存器或内存地址作为源，以寄存器作为目的。特殊用cltq把%eax符号扩展到%rax。
    - （push S\pop D）（'b'\'w'\'l'\'q'），栈指针%rsp保存着栈顶元素的地址。将一个四字值压入栈中，首先要将栈指针减8，然后将新值写到新的栈顶位置。弹出一个四字的操作同理。程序也可以用标准的内存寻址方法访问栈内的任意位置。

## 算术和逻辑操作 ##

1. 以下未特别指明都包含四种不同大小数据的指令：
    - （leap S,D），加载有效地址，目的操作数必须是一个寄存器。不包含四种不同大小数据的指令。
    - （INC D），加1，一元操作，操作数可以是一个寄存器或内存位置。后面同理。
    - （DEC D），减1。
    - （NEG D），取负。
    - （NOT D），取补。
    - （ADD S,D)，加，二元操作，源操作数是第一个，目的操作数是第二个，第一个操作数可以是立即数、寄存器或内存位置。第二个操作数可以是寄存器或内存位置。注意不能同时将内存位置作为源和目的操作数。后面同理。
    - （SUB S,D)，减。
    - （IMUL S,D)，乘。
    - （XOR S,D)，异或。
    - （OR S,D)，或。
    - （AND S,D)，与。
    - （SAL\SHL k,D)，左移，移位操作，k是移位量。移位量可以是立即数，或者放在单字节寄存器%cl中。对w位长的数据进行操作，实际的移位量是由%cl寄存器的低m位决定的，$2^m=w$，多余的位会被忽略。目的操作数可以是寄存器或内存位置。
    - （SAR k,D)，算术右移。
    - （SHR k,D)，逻辑右移。
2. Intel把16字节的数称为八字，以下是支持产生两个64位数字的全128位乘积以及整数除法的指令：
    - （imulq S)，有符号全乘法，要求一个参数必须在寄存器%rax中，另一个作为指令的源操作数给出。乘积存放在寄存器%rdx（高64位）和%rax（低64位）中。
    - （mulq S)，无符号全乘法。
    - （clto），转换为八字。
    - （idivq S），有符号除法，将寄存器%rdx（高64位）和%rax（低64位）中的128位数作为被除数，除数作为指令的操作数给出。指令将商存储在寄存器%rax中，将余数存储在寄存器%rdx中。
    - （divq S），无符号除法，通常%rdx会事先设置为0。
    - （cqto\cqo），它隐含的读出%rax的符号位，并将它复制到%rdx的所有位。

## 控制 ##

1. CPU维护一组单个位的条件码寄存器，它们描述了最近的算术或逻辑操作的属性：

    - CF，进位标志。最高位产生了进位，检查无符号操作的溢出。
    - ZF，零标志，得到结果为0。
    - SF，符号标志，得到结果为负数。
    - OF，溢出标志，导致一个补码溢出（正溢出或负溢出）。

2. 除leaq指令外**算术和逻辑操作1**中其他指令都会改变条件码：
    - CMP（'b'/'w'/'l'/'q'） $S_1,S_2$，类似SUB，只设置条件码而不更新目的寄存器。
    - TEST（'b'/'w'/'l'/'q'） $S_1,S_2$，类似AND。

3. 根据条件码的某种组合，将一个字节设置为0或者1：
    |指令       |同义名         |效果                 |设置条件           |
    |-----------|--------------|--------------------|-----------------|
    |sete   D   |setz          |D <- ZF             |相等/零           |
    |setne  D   |setnz         |D <- ~ZF            |不相等/非零        |
    |sets   D   |              |D <- SF             |负数              |
    |setns  D   |              |D <- ~SF            |非负数            |
    |setg   D   |setnle        |D <- ~(SF^OF) & ~ZF |大于（有符号>)     |
    |setge  D   |setnl         |D <- ~(SF^OF)       |大于等于（有符号>=) |
    |setl   D   |setnge        |D <- SF^OF          |小于（有符号<)     |
    |setle  D   |setng         |D <- (SF^OF) \| ZF   |小于等于（有符号<=) |
    |seta   D   |setnbe        |D <- ~CF & ~ZF      |超过（无符号>)      |
    |setae  D   |setnb         |D <- ~CF            |超过或相等（无符号>=)|
    |setb   D   |setnae        |D <- CF             |低于（无符号<)      |
    |setbe  D   |setna         |D <- CF \| ZF        |低于或相等（无符号<=)|

4. 跳转指令将跳转目的指令的地址编码为跳转指令的一部分（通常用标号Label指明），间接跳转的写法是‘*’后面跟一个操作数指示符：
    |指令           |同义名         |跳转条件           |描述               |
    |--------------|--------------|------------------|------------------|
    |jmp  Label    |              |1                 |直接跳转            |
    |jmp *Operand  |              |1                 |间接跳转            |
    |je   Label    |jz            |ZF                |相等\零            |
    |jne  Label    |jnz           |~ZF               |不相等\非零         |
    |js   Label    |              |SF                |负数               |
    |jns  Label    |              |~SF               |非负数             |
    |jg   Label    |jnle          |~(SF^OF) & ~ZF    |大于（有符号>)      |
    |jge  Label    |jnl           |~(SF^OF)          |大于或等于（有符号>=)|
    |jl   Label    |jnge          |SF^OF             |小于（有符号<)      |
    |jle  Label    |jng           |(SF^OF) \| ZF     |小于或等于（有符号<=)  |
    |ja   Label    |jnbe          |~CF & ~ZF        |超过（无符号>)      |
    |jae  Label    |jnb           |~CF               |超过或相等（无符号>=)|
    |jb   Label    |jnae          |CF                |低于（无符号<)      |
    |jbe  Label    |jna           |CF \| ZF          |低于或相等（无符号<=)|

5. 跳转指令有两种不同的编码：
    - PC-relative，将目标指令的地址与紧跟在跳转指令后面的那条指令的地址之间的差作为编码。这些地址的偏移量可以编码为1、2或4个字节。
    - ‘绝对’地址，用4个字节直接指定目标。

6. 条件传送指令有两个操作数：源寄存器或内存位置S，目的寄存器R。源和目的的值可以是16位、32位或64位长，不支持单字节条件传送，可以从目标寄存器的名字推断出条件传送指令的操作数长度，所以对不同操作数长度可以使用同一个指令名字：
    |指令           |同义名         |传送条件           |描述               |
    |--------------|--------------|------------------|------------------|
    |cmove   S,R   |cmovz         |ZF                |相等\零            |
    |cmovne  S,R   |cmovnz        |~ZF               |不相等\非零         |
    |cmovs   S,R   |              |SF                |负数               |
    |cmovns  S,R   |              |~SF               |非负数             |
    |cmovg   S,R   |cmovnle       |~(SF^OF) & ~ZF    |大于（有符号>)      |
    |cmovge  S,R   |cmovnl        |~(SF^OF)          |大于或等于（有符号>=)|
    |cmovl   S,R   |cmovnge       |SF^OF             |小于（有符号<)      |
    |cmovle  S,R   |cmovng        |(SF^OF) \| ZF     |小于或等于（有符号<=)|
    |cmova   S,R   |cmovnbe       |~CF & ~ZF         |超过（无符号>)      |
    |cmovae  S,R   |cmovnb        |~CF               |超过或相等（无符号>=)|
    |cmovb   S,R   |cmovnae       |CF                |低于（无符号<)      |
    |cmovbe  S,R   |cmovna        |CF \| ZF          |低于或相等（无符号<=)|

7. 并不是所有情况都适合条件传送指令，因为对条件传送指令，两个结果表达式都会求值，当其中一个结果表达式可能产生错误条件或副作用时，就会导致非法的行为。这种情况下必须用条件分支来编译这段代码。

8. switch根据一个整数索引值进行多重分支。跳转表是一个数组，表项i是一个代码段的地址，这个代码段实现当开关索引值等于i时程序应该采取的动作。

## 过程 ##

1. 过程必须包括的属性：传递控制、传递数据、分配和释放内存

2. 程序可以用栈来管理它的过程所需要的存储空间，在x86-64中栈向低地址方向增长，%rsp指向栈顶元素。将栈指针减小一个适当的量可以为没有指定初始值的数据在栈上分配空间，通过增加栈指针来释放空间。这部分空间称为**栈帧**，当过程P调用过程Q时，会把Q返回时需要的返回地址压入P的栈帧中。需要6个以上的传递参数（指针和整数）的过程，可以在自己的栈帧里存储好这些参数。当局部变量都可以保存在寄存器中，而且改过程为叶子过程（不回调用任何其他函数）时，这种函数就不需要栈帧。

3. 控制转移指令：
    - （call Label）/（call *Operand），过程调用。指令把紧跟在后面的那条指令的地址A压入栈中，并将PC设置为调用过程的起始地址。
    - （ret），从过程调用中返回。会从栈中弹出地址A并设置PC。

4. 在传递数据时，如果参数大小超过6个，那么7～n的参数将存放到栈上，且参数7位于栈顶。通过栈传递参数时，所有的数据大小都向8的倍数对齐。参数到位后，程序可以执行call指令将控制转移到新的过程，此时返回地址被压入栈中，所以参数位于相对于当前栈指针更高的地址中。

5. 栈上的局部存储，常见的情况：
    - 寄存器不足够存放所有的本地数据。
    - 对一个局部变量使用地址运算符‘&’，因此必须能够为它产生一个地址。
    - 某些局部变量是数组或结构，因此必须能够通过数组或结构引用被访问到。

6. 寄存器组是唯一被所有过程共享的资源，所有的过程都必须遵循一个规则，以保证被调用者Q不会覆盖调用者P稍后会使用的寄存器值。
    - 寄存器%rbx、%rbp和%r12～%r15，为被调用者Q保存寄存器。这些寄存器必须保证在P调用任何过程Q后都保持不变。如果Q要修改这些寄存器的值，必须先将原来的值保存在栈中，然后在Q返回前从栈中恢复这些值。
    - 其他的寄存器（除了栈指针%rsp），为调用者保存寄存器。这些寄存器，在P调用Q后可能被修改，所以值必须由P自己保存。

## 数组分配和访问 ##

## 异质的数据结构 ##

1. struct将不同类型的对象组合到一起创建数据类型，union允许用几种不同的类型来引用一个对象。

2. struct结构的各个字段的选取完全是在编译时处理的，机器代码不包含关于字段声明或字段名字的信息。

3. 当用union联合将各种不同大小的数据类型结合到一起时（例如其中有数组），字节顺序（大端、小端）会影响得到的值。

4. 数据对齐的原则：任何K字节的基本对象的地址必须是K的倍数。

## 在机器级程序中将控制与数据结合起来 ##

1. 理解指针：
    - 每个指针都对应一个类型，表明该指针指向的是哪一类对象。
    - 每个指针都有一个值，这个值是某个指定类型的对象的地址。
    - 指针用&运算符创建。
    - *操作符用于间接引用指针，其结果是一个值，它的类型与该指针的类型一致。
    - 数组的名字可以像指针变量一样引用（但不能修改）。
    - 将指针从一种类型强制转换成另一种类型，只改变它的类型，不改变它的值。强制类型转换改变了指针运算的伸缩。
    - 指针也可以指向函数，函数指针的值是该函数机器代码表示中第一条指令的地址。

2. 缓冲区溢出漏洞可以由内存的越界写导致。任何到外部环境的接口都应该是“防弹的”，这样，外部代理的行为才不会导致系统出现错误。

3. 现在编译器和操作系统实现的对抗缓冲区溢出攻击的机制：
    - 栈随机化，即使许多机器运行同样的代码，它们的栈地址都是不同的。实现的方式是在程序开始时，在栈上分配一段0～n字节之间随机大小的空间。它是**地址空间布局随机化**（ASLR）技术中的一种，程序的不同部分，包括程序代码、库代码、栈、全局变量和堆数据，每次运行时会被加载到内存的不同区域。然而这种技术能够被**空操作雪橇**（nop sled）破解，只要在攻击代码前插入很长的一段nop指令，就可以通过枚举找出实际攻击代码的起始地址。
    - 栈破坏检测，栈保护者机制（金丝雀值\哨兵值）是在栈帧中任何局部缓冲区与栈状态之间存储一个特殊的值。在恢复寄存器状态和从函数返回之前，检查该值是否被改变并中止程序。
    - 限制可执行代码区域，限制哪些内存区域能够存放可执行代码。

4. 管理变长栈帧，使用寄存器%rbp作为帧指针（基指针）。

## 浮点代码 ##

1. AVX浮点体系结构允许数据存储在16个YMM寄存器中，每个YMM寄存器保存32个字节，其中低16字节可以作为XMM寄存器来访问。当对标量数据操作时，这些寄存器只保存浮点数，而且只使用低32位（float）或64位（double）。

2. 浮点数据传送指令（M代表内存，X代表寄存器）：
    |指令           |源         |目的           |描述                   |
    |--------------|-----------|--------------|-----------------------|
    |vmovss        |$M_{32}$   |X             |传送单精度数             |
    |vmovss        |X          |$M_{32}$      |传送单精度数             |
    |vmovsd        |$M_{64}$   |X             |传送双精度数             |
    |vmovsd        |X          |$M_{64}$      |传送双精度数             |
    |vmovaps       |X          |X             |传送对齐的封装好的单精度数 |
    |vmovapd       |X          |X             |传送对齐的封装好的双精度数 |

3. 浮点数据转换指令（指令会执行截断，将值向0舍入）：
    |指令           |源         |目的           |描述                   |
    |--------------|-----------|--------------|-----------------------|
    |vcvttss2si    |X/$M_{32}$ |$R_{32}$      |单精度->整数            |
    |vcvttsd2si    |X/$M_{64}$ |$R_{32}$      |双精度->整数            |
    |vcvttss2siq   |X/$M_{32}$ |$R_{64}$      |单精度->四字整数         |
    |vcvttsd2siq   |X/$M_{64}$ |$R_{64}$      |双精度->四字整数         |

4. 三操作数浮点转换指令（在一般的使用场景下第二个源和目的操作数是一样的）：
    |指令           |源1               |源2           |目的           |描述                    |
    |--------------|------------------|--------------|---------------|----------------------|
    |vcvtsi2ss     |$M_{32}$/$R_{32}$ |X             |X              |把整数转换成单精度数     |
    |vcvtsi2sd     |$M_{32}$/$R_{32}$ |X             |X              |把整数转换成双精度数     |
    |vcvtsi2ssq    |$M_{64}$/$R_{64}$ |X             |X              |把四字整数转换成单精度数  |
    |vcvtsi2sdq    |$M_{64}$/$R_{64}$ |X             |X              |把四字整数转换成双精度数  |

5. 将单精度转换成双精度值，汇编代码如下：
    vunpcklps %xmm0, %xmm0, %xmm0
    vcvtps2pd %xmm0, %xmm0
将双精度转换成单精度值，汇编代码如下：
    vmovddup %xmm0, %xmm0
    vcvtpd2psx %xmm0, %xmm0
（然而实际上在笔者MacOS上测试，将双精度转换成单精度使用cvtsd2ss	%xmm0, %xmm0，将单精度转换成双精度使用cvtss2sd	%xmm0, %xmm0)

6. 过程中的浮点代码：
    - XMM寄存器最多可以传递8个浮点参数，从%xmm0~%xmm7。
    - 函数使用寄存器%xmm0来返回浮点值。
    - 所有的XMM寄存器都是调用者保存的。

7. 浮点运算操作（$S_1$可以是XMM寄存器或内存位置，$S_2$和目的操作数都必须是XMM寄存器）：
    |单精度         |双精度      |效果                   |描述          |
    |--------------|-----------|----------------------|--------------|
    |vaddss        |vaddsd     |D <- $S_2+S_1$        |浮点数加       |
    |vsubss        |vsubsd     |D <- $S_2-S_1$        |浮点数减       |
    |vmulss        |vmulsd     |D <- $S_2*S_1$        |浮点数乘       |
    |vdivss        |vdivsd     |D <- $S_2/S_1$        |浮点数除       |
    |vmaxss        |vmaxsd     |D <- max($S_2,S_1$)   |浮点数最大值    |
    |vminss        |vminsd     |D <- min($S_2,S_1$)   |浮点数最小值    |
    |sqrtss        |sqrtsd     |D <- $\sqrt{S_1}$     |浮点数平方根    |

8. AVX浮点操作不能以立即数值作为操作数。编译器必须为所有的浮点常量值分配和初始化存储空间，然后代码再把这些值从内存读入。
9. 浮点位级操作：
    |单精度         |双精度      |效果                   |描述          |
    |--------------|-----------|----------------------|--------------|
    |vxorps        |vorpd      |D<-$S_2$^$S_1$        |位级异或       |
    |vandps        |andpd      |D<-$S_2$&$S_1$        |位级与         |

10. 浮点比较指令，$S_2$必须在XMM寄存器中，$S_1$可以在内存或XMM寄存器中。
    |指令                |基于          |描述        |
    |-------------------|-------------|------------|
    |ucomiss $S_1$,$S_2$|$S_2$-$S_1$  |比较单精度值  |
    |ucomisd $S_1$,$S_2$|$S_2$-$S_1$  |比较双精度值  |
    浮点比较指令会设置3个条件码，当任一操作数为NaN时，会出现无序的情况。
    |顺序$S_2$:$S_1$     |CF           |ZF          |PF        |
    |-------------------|-------------|------------|----------|
    |无序的              |1            |1           |1         |
    |$S_2$<$S_1$        |1            |0           |0         |
    |$S_2$=$S_1$        |0            |1           |0         |
    |$S_2$>$S_1$        |0            |0           |0         |

## 家庭作业未完成 ##

- 72、73、74、75
